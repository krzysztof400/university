# Sprawozdanie: Bazy danych i zarządzanie informacją - Lista 4

---

## 1. Konfiguracja bazy w chmurze

Założono darmowe konto na platformie MongoDB Atlas. Skonfigurowano klaster (Shared Free), utworzono użytkownika bazy danych z uprawnieniami *readWriteAnyDatabase* oraz dodano adres IP do listy dostępu (Network Access). Uzyskano *Connection String* do połączenia z aplikacji.

---

## 2. Tworzenie bazy, kolekcji i wstawianie danych (Python)

Do komunikacji z bazą wykorzystano język Python oraz sterownik `pymongo`. Poniższy kod łączy się z bazą `library`, czyści kolekcje (dla idenmpotentności skryptu) i wstawia wymagane dane.

### Kod inicjalizujący dane:

```python
from pymongo import MongoClient
from datetime import datetime
import urllib.parse

# Konfiguracja połączenia
password = urllib.parse.quote_plus("")

uri = f"mongodb+srv://krzysztof400:{password}@krzysztof400.uun4lbq.mongodb.net/?retryWrites=true&w=majority"

try:
    client = MongoClient(uri)
    client.admin.command('ping')
    print("Połączono z MongoDB Atlas!")
    
    db = client.library
    
except Exception as e:
    print(f"Wystąpił błąd połączenia: {e}")

# Czyszczenie kolekcji przed testem
db.authors.drop()
db.books.drop()
db.reviews.drop()

# 1. Dodawanie Autorów
authors_data = [
    {
        "name": {"first": "Andrzej", "last": "Sapkowski"},
        "country": "Polska",
        "birth": datetime(1948, 6, 21),
        "death": None, # Data śmierci nieznana/żyje 
        "awards": [{"name": "Paszport Polityki", "year": 1997}]
    },
    {
        "name": {"first": "Stanisław", "last": "Lem"},
        "country": "Polska",
        "birth": datetime(1921, 9, 12),
        "death": datetime(2006, 3, 27),
        "awards": [{"name": "Order Orła Białego", "year": 1996}]
    },
    {
        "name": {"first": "J.R.R.", "last": "Tolkien"},
        "country": "UK",
        "birth": datetime(1892, 1, 3),
        "death": datetime(1973, 9, 2),
        "awards": []
    },
    {
        "name": {"first": "J.K.", "last": "Rowling"},
        "country": "UK",
        "birth": datetime(1965, 7, 31),
        "death": None, # Brak pola awards (test braku pola)
    }
]

res_authors = db.authors.insert_many(authors_data)
# Pobranie ID wstawionych autorów do referencji
sapkowski_id = res_authors.inserted_ids[0]
lem_id = res_authors.inserted_ids[1]
tolkien_id = res_authors.inserted_ids[2]
rowling_id = res_authors.inserted_ids[3]

# 2. Dodawanie Książek (referencje + poddokumenty)
books_data = [
    {
        "title": "Ostatnie życzenie",
        "isbn": "978-83-7578-063-5",
        "publication_year": 1993,
        "language": "Polski",
        "author": sapkowski_id,
        "publisher": {"name": "SuperNOWA", "country": "Polska"},
        "genres": ["Fantasy", "Opowiadania"]
    },
    {
        "title": "Miecz przeznaczenia",
        "isbn": "978-83-7578-064-2",
        "publication_year": 1992,
        "language": "Polski",
        "author": sapkowski_id,
        "publisher": {"name": "SuperNOWA", "country": "Polska"},
        "genres": ["Fantasy", "Opowiadania"]
    },
    {
        "title": "Krew elfów",
        "isbn": "978-83-7578-065-9",
        "publication_year": 1994,
        "language": "Polski",
        "author": sapkowski_id,
        "publisher": {"name": "SuperNOWA", "country": "Polska"},
        "genres": ["Fantasy", "Powieść"]
    },
    {
        "title": "Solaris",
        "isbn": "978-83-08-04905-1",
        "publication_year": 1961,
        "language": "Polski",
        "author": lem_id,
        "publisher": {"name": "Wydawnictwo Literackie", "country": "Polska"},
        "genres": ["Sci-Fi", "Filozoficzna"]
    },
    {
        "title": "The Hobbit",
        "isbn": "978-0-261-10295-6",
        "publication_year": 1937,
        "language": "English",
        "author": tolkien_id,
        "publisher": {"name": "George Allen & Unwin", "country": "UK"},
        "genres": ["Fantasy"]
    }
]

res_books = db.books.insert_many(books_data)
wiedzmin_id = res_books.inserted_ids[0] # ID "Ostatnie życzenie"

# 3. Dodawanie Recenzji
reviews_data = [
    {
        "book_id": wiedzmin_id,
        "reviewer": "JanKowalski",
        "rating": 5,
        "text": "Arcydzieło!"
    },
    {
        "book_id": wiedzmin_id,
        "reviewer": "AnnaNowak",
        "rating": 2, # Ocena poniżej 3
        "text": "Nie podoba mi się styl."
    },
    {
        "book_id": wiedzmin_id,
        "reviewer": "JanKowalski", # Ten sam autor recenzji
        "rating": 5,
        "text": "Po ponownym przeczytaniu nadal super."
    }
]
db.reviews.insert_many(reviews_data)

print("Dane zostały pomyślnie załadowane.")
```
### Odpowiedzi na pytania:
1. Co się stanie, jeżeli data śmierci to null? Baza danych MongoDB przyjmuje wartość null (w Pythonie None) bez błędów. Jest to poprawna reprezentacja braku informacji lub faktu, że dana osoba żyje.
2. Co się stanie, jeżeli pomylisz nazwę pola, typ danych lub pominiesz pole? MongoDB jest bazą schema-less. Operacja zakończy się powodzeniem. Dokument zostanie zapisany z takimi polami, jakie podano. Brakujące pola nie zostaną utworzone.
3. Czy można wprowadzić schemat wymuszający poprawność danych? Tak, można to zrobić definiując walidację (Validator) podczas tworzenia kolekcji, używając składni $jsonSchema. Pozwala to określić wymagane pola oraz typy danych.
4. Wpływ metody przechowywania informacji o recenzencie: Zapisanie recenzenta jako prostego stringa (np. nick) ułatwia szybki odczyt recenzji (brak konieczności złączeń/lookup), ale utrudnia aktualizację danych recenzenta (zmiana nicku wymaga edycji wielu dokumentów). 
## 3. Wyszukiwanie i agregacje
```python
from pymongo import MongoClient
from datetime import datetime
import urllib.parse

# Konfiguracja połączenia
password = urllib.parse.quote_plus("")

uri = f"mongodb+srv://krzysztof400:{password}@krzysztof400.uun4lbq.mongodb.net/?retryWrites=true&w=majority"

try:
    client = MongoClient(uri)
    client.admin.command('ping')
    print("Połączono z MongoDB Atlas!")
    
    db = client.library
    
except Exception as e:
    print(f"Wystąpił błąd połączenia: {e}")

# Czyszczenie kolekcji przed testem
db.authors.drop()
db.books.drop()
db.reviews.drop()

# 1. Wyszukaj wszystkie książki napisane po polsku w gatunku "Fantasy"
print("--- Książki Fantasy po polsku ---")
cursor = db.books.find({"language": "Polski", "genres": "Fantasy"})
for doc in cursor:
    print(f"Tytuł: {doc['title']}")

# 2. Książki, których średnia ocena w recenzjach to co najmniej 4
print("\n--- Książki ze średnią oceną >= 4 ---")
pipeline_avg = [
    {"$group": {"_id": "$book_id", "avgRating": {"$avg": "$rating"}}},
    {"$match": {"avgRating": {"$gte": 4}}},
    {"$lookup": {
        "from": "books",
        "localField": "_id",
        "foreignField": "_id",
        "as": "book_info"
    }},
    {"$project": {"book_info.title": 1, "avgRating": 1}}
]
for doc in db.reviews.aggregate(pipeline_avg):
    print(doc)

# 3. Wyszukaj książki autora o nazwisku "Lem"
print("\n--- Książki Stanisława Lema ---")
pipeline_lem = [
    {"$match": {"name.last": "Lem"}},
    {"$lookup": {
        "from": "books",
        "localField": "_id",
        "foreignField": "author",
        "as": "books"
    }},
    {"$project": {"books.title": 1}}
]
for doc in db.authors.aggregate(pipeline_lem):
    print(doc)

# 4. Książki polskich autorów + nazwiska + średnia ocena
print("\n--- Polscy autorzy i oceny ich książek ---")
pipeline_pl = [
    {"$lookup": {
        "from": "authors",
        "localField": "author",
        "foreignField": "_id",
        "as": "author"
    }},
    {"$unwind": "$author"},
    {"$match": {"author.country": "Polska"}},
    {"$lookup": {
        "from": "reviews",
        "localField": "_id",
        "foreignField": "book_id",
        "as": "reviews"
    }},
    {"$project": {
        "title": 1,
        "author_lastname": "$author.name.last",
        "avg_rating": {"$avg": "$reviews.rating"}
    }}
]
for doc in db.books.aggregate(pipeline_pl):
    print(doc)

# 5. Nazwisko autora oraz liczba napisanych książek
print("\n--- Liczba książek per autor ---")
pipeline_count = [
    {"$lookup": {
        "from": "books",
        "localField": "_id",
        "foreignField": "author",
        "as": "books"
    }},
    {"$project": {
        "lastname": "$name.last",
        "book_count": {"$size": "$books"}
    }}
]
for doc in db.authors.aggregate(pipeline_count):
    print(f"{doc['lastname']}: {doc['book_count']}")

# 6. Średnia ocena książek każdego autora
print("\n--- Średnia ocena autora ---")
pipeline_auth_avg = [
    {"$lookup": {
        "from": "reviews",
        "localField": "_id",
        "foreignField": "book_id",
        "as": "reviews"
    }},
    {"$unwind": "$reviews"},
    {"$lookup": {
        "from": "authors",
        "localField": "author",
        "foreignField": "_id",
        "as": "author_info"
    }},
    {"$unwind": "$author_info"},
    {"$group": {
        "_id": "$author_info._id",
        "lastname": {"$first": "$author_info.name.last"},
        "avg_rating": {"$avg": "$reviews.rating"}
    }}
]
for doc in db.books.aggregate(pipeline_auth_avg):
    print(f"{doc['lastname']}: {doc['avg_rating']}")

# 7. Znajdź autorów, którzy nie otrzymali żadnej nagrody
print("\n--- Autorzy bez nagród ---")
no_awards = db.authors.find({
    "$or": [
        {"awards": {"$size": 0}},
        {"awards": {"$exists": False}}
    ]
})
for doc in no_awards:
    print(doc['name']['last'])

# 8. Policz ile książek przypada na każdy gatunek literacki
print("\n--- Liczba książek wg gatunku ---")
pipeline_genres = [
    {"$unwind": "$genres"},
    {"$group": {
        "_id": "$genres",
        "count": {"$sum": 1}
    }}
]
for doc in db.books.aggregate(pipeline_genres):
    print(f"{doc['_id']}: {doc['count']}")

# 9. Znajdź osobę, która napisała najwięcej recenzji
print("\n--- Najaktywniejszy recenzent ---")
pipeline_top_reviewer = [
    {"$group": {
        "_id": "$reviewer",
        "count": {"$sum": 1}
    }},
    {"$sort": {"count": -1}},
    {"$limit": 1}
]
for doc in db.reviews.aggregate(pipeline_top_reviewer):
    print(f"{doc['_id']} napisał {doc['count']} recenzji")

# 10. Policz średnią ocenę książek w zależności od języka
print("\n--- Średnia ocena wg języka ---")
pipeline_lang = [
    {"$lookup": {
        "from": "reviews",
        "localField": "_id",
        "foreignField": "book_id",
        "as": "reviews"
    }},
    {"$unwind": "$reviews"},
    {"$group": {
        "_id": "$language",
        "avg_rating": {"$avg": "$reviews.rating"}
    }}
]
for doc in db.books.aggregate(pipeline_lang):
    print(f"{doc['_id']}: {doc['avg_rating']}")
```