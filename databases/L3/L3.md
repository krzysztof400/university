## 1

### Utwórz nową bazę danych o dowolnej nazwie a w niej tabele: Ludzie, Zawody, Pracownicy. Czy dobrym pomysłem jest stosowanie nr PESEL jako klucza? Jeżeli uważasz, że nie, popraw to. Zadbaj o prawidłowy format kolumny PESEL, brak ujemnych wartości oraz aby pensja_min < pensja_max. Do tabeli Ludzie wprowadź informacje na temat 5 osób niepełnoletnich, 45 osób pełnoletnich (<60 lat) oraz 5 osób seniorów (>=60 lat). Tabelę zawody uzupełnij zawodami: polityk, nauczyciel, lekarz, informatyk. Z wykorzystaniem kursora przypisz zawody. Zadbaj o to, aby żaden lekarz płci męskiej nie był starszy niż 65 lat a żaden lekarz płci żeńskiej nie był starszy niż 60 lat.

Stosowanie numeru PESEL jako klucza głównego (Primary Key) nie jest zalecane.

1.  **Wydajność:** PESEL to ciąg znaków (`CHAR(11)`), co jest mniej wydajne w indeksowaniu i złączeniach (JOIN) niż typ liczbowy (`INT`).
2.  **Bezpieczeństwo (RODO):** PESEL jest daną wrażliwą. Używanie go jako klucza obcego w wielu tabelach zwiększa ryzyko niepotrzebnego ujawnienia danych.
    **Rozwiązanie:** Wprowadzono sztuczny klucz `id` (INT AUTO_INCREMENT), a na kolumnę PESEL nałożono ograniczenie `UNIQUE`.

```sql
CREATE DATABASE Lab3_Firma;
USE Lab3_Firma;

-- Tabela Zawody
CREATE TABLE Zawody (
    zawod_id INT AUTO_INCREMENT PRIMARY KEY,
    nazwa VARCHAR(50),
    pensja_min FLOAT CHECK (pensja_min > 0),
    pensja_max FLOAT CHECK (pensja_max > 0),
    CONSTRAINT chk_widełki CHECK (pensja_min < pensja_max)
);

-- Tabela Ludzie (z id zamiast PESEL jako PK)
CREATE TABLE Ludzie (
    id INT AUTO_INCREMENT PRIMARY KEY,
    PESEL CHAR(11) UNIQUE,
    imie VARCHAR(30),
    nazwisko VARCHAR(30),
    data_urodzenia DATE,
    plec ENUM('K', 'M'),
    -- Walidacja formatu PESEL (długość i cyfry)
    CONSTRAINT chk_pesel CHECK (LENGTH(PESEL) = 11 AND PESEL REGEXP '^[0-9]+$')
);

-- Tabela Pracownicy
CREATE TABLE Pracownicy (
    id INT AUTO_INCREMENT PRIMARY KEY,
    ludzie_id INT, -- Klucz obcy do ID zamiast PESEL
    zawod_id INT,
    pensja FLOAT CHECK (pensja > 0),
    FOREIGN KEY (ludzie_id) REFERENCES Ludzie(id),
    FOREIGN KEY (zawod_id) REFERENCES Zawody(zawod_id)
);

-- Uzupełnienie zawodów
INSERT INTO Zawody (nazwa, pensja_min, pensja_max) VALUES
('polityk', 10000, 25000),
('nauczyciel', 3000, 5500),
('lekarz', 6000, 15000),
('informatyk', 5000, 20000);

-- Procedura generująca dane (5 niepełnoletnich, 45 dorosłych, 5 seniorów)
DELIMITER //
CREATE PROCEDURE GenerujLudzi()
BEGIN
    DECLARE i INT DEFAULT 0;

    -- 5 niepełnoletnich (rok ur > 2007)
    WHILE i < 5 DO
        INSERT INTO Ludzie (PESEL, imie, nazwisko, data_urodzenia, plec)
        VALUES (CONCAT('0821010000', i), CONCAT('Dziecko', i), 'Nowak', '2010-01-01', IF(i%2=0,'M','K'));
        SET i = i + 1;
    END WHILE;

    -- 45 dorosłych (wiek 18-59)
    SET i = 0;
    WHILE i < 45 DO
        INSERT INTO Ludzie (PESEL, imie, nazwisko, data_urodzenia, plec)
        VALUES (CONCAT('800101000', LPAD(i, 2, '0')), CONCAT(IF(i%2=0,'Adam','Anna'), i), 'Kowalski', '1980-05-15', IF(i%2=0,'M','K'));
        SET i = i + 1;
    END WHILE;

    -- 5 seniorów (wiek >= 60)
    SET i = 0;
    WHILE i < 5 DO
        INSERT INTO Ludzie (PESEL, imie, nazwisko, data_urodzenia, plec)
        VALUES (CONCAT('5501010000', i), CONCAT('Senior', i), 'Wisniewski', '1955-01-01', IF(i%2=0,'M','K'));
        SET i = i + 1;
    END WHILE;
END //
DELIMITER ;

CALL GenerujLudzi();

-- Procedura z KURSOREM przypisująca pracę
DELIMITER //
CREATE PROCEDURE PrzydzielPrace()
BEGIN
    DECLARE done INT DEFAULT FALSE;
    DECLARE v_id INT;
    DECLARE v_data_urodzenia DATE;
    DECLARE v_plec CHAR(1);
    DECLARE v_wiek INT;
    DECLARE v_zawod_id INT;
    DECLARE v_pensja FLOAT;

    -- Kursor dla osób pełnoletnich (>= 18 lat)
    DECLARE cur CURSOR FOR
        SELECT id, data_urodzenia, plec
        FROM Ludzie
        WHERE TIMESTAMPDIFF(YEAR, data_urodzenia, CURDATE()) >= 18;

    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;

    OPEN cur;

    read_loop: LOOP
        FETCH cur INTO v_id, v_data_urodzenia, v_plec;
        IF done THEN LEAVE read_loop; END IF;

        SET v_wiek = TIMESTAMPDIFF(YEAR, v_data_urodzenia, CURDATE());

        -- Losowanie zawodu (ID 1-4)
        SET v_zawod_id = FLOOR(1 + RAND() * 4);

        -- Walidacja wieku lekarzy: M <= 65, K <= 60
        IF v_zawod_id = 3 THEN -- 3 to lekarz
            IF (v_plec = 'M' AND v_wiek > 65) OR (v_plec = 'K' AND v_wiek > 60) THEN
                -- Zmiana na nauczyciela (ID 2) jeśli za stary na lekarza
                SET v_zawod_id = 2;
            END IF;
        END IF;

        -- Średnia pensja dla zawodu
        SELECT (pensja_min + pensja_max) / 2 INTO v_pensja FROM Zawody WHERE zawod_id = v_zawod_id;

        INSERT INTO Pracownicy (ludzie_id, zawod_id, pensja)
        VALUES (v_id, v_zawod_id, v_pensja);

    END LOOP;

    CLOSE cur;
END //
DELIMITER ;

CALL PrzydzielPrace();
```

## 2

### W tabeli Ludzie utwórz indeks złożony na kolumnach (plec, imie), a w Pracownicy indeks na kolumnie (pensja). Za pomocą odpowiednich kwerend SQL (EXPLAIN) wyciągnij dane i odpowiedz na pytania.

```sql
-- Tworzenie indeksów
CREATE INDEX idx_plec_imie ON Ludzie(plec, imie);
CREATE INDEX idx_pensja ON Pracownicy(pensja);

-- 1. Kobiety na 'A'
EXPLAIN SELECT * FROM Ludzie WHERE plec = 'K' AND imie LIKE 'A%';

-- 2. Wszystkie kobiety
EXPLAIN SELECT * FROM Ludzie WHERE plec = 'K';

-- 3. Osoby na 'K' (bez podania płci)
EXPLAIN SELECT * FROM Ludzie WHERE imie LIKE 'K%';

-- 4. Zarabiający poniżej 2000
EXPLAIN SELECT * FROM Pracownicy WHERE pensja < 2000;

-- 5. Informatycy M powyżej 10000
EXPLAIN SELECT * FROM Pracownicy P
JOIN Ludzie L ON P.ludzie_id = L.id
JOIN Zawody Z ON P.zawod_id = Z.zawod_id
WHERE Z.nazwa = 'informatyk' AND L.plec = 'M' AND P.pensja > 10000;
```

**Odpowiedzi:**

- **Obecne indeksy:** `idx_plec_imie` (złożony) w tabeli Ludzie, `idx_pensja` w tabeli Pracownicy.
- **Użycie indeksów:**
  - **Użyty `idx_plec_imie`:** W zapytaniu o kobiety na 'A' oraz w zapytaniu o wszystkie kobiety (wykorzystany lewy prefiks indeksu).
  - **Nieużyty (lub mało efektywny):** W zapytaniu tylko o imię na 'K', ponieważ pominięto pierwszą kolumnę indeksu (`plec`).
  - **Użyty `idx_pensja`:** W zapytaniu o zarobki `< 2000` (zakres liczbowy).

## 3

### Napisz procedurę, która daje wszystkim wykonującym podany zawód 5% podwyżki przy zachowaniu widełek. Operacja ma być transakcyjna (wszyscy albo nikt).

```sql
DELIMITER //
CREATE PROCEDURE Podwyzka(IN p_nazwa_zawodu VARCHAR(50))
BEGIN
    DECLARE v_error BOOL DEFAULT FALSE;
    DECLARE v_zawod_id INT;
    DECLARE v_max_pensja FLOAT;

    -- Pobierz ID i max pensję
    SELECT zawod_id, pensja_max INTO v_zawod_id, v_max_pensja
    FROM Zawody WHERE nazwa = p_nazwa_zawodu;

    START TRANSACTION;

    -- Próba podwyżki
    UPDATE Pracownicy
    SET pensja = pensja * 1.05
    WHERE zawod_id = v_zawod_id;

    -- Weryfikacja czy ktoś przekroczył widełki
    IF EXISTS (SELECT 1 FROM Pracownicy WHERE zawod_id = v_zawod_id AND pensja > v_max_pensja) THEN
        SET v_error = TRUE;
    END IF;

    IF v_error THEN
        ROLLBACK;
        SELECT 'Błąd: Przekroczono widełki płacowe. Wycofano zmiany.' AS Wynik;
    ELSE
        COMMIT;
        SELECT 'Sukces: Przyznano podwyżki.' AS Wynik;
    END IF;
END //
DELIMITER ;
```

## 4

### Za pomocą konstrukcji PREPARE statement przygotuj zapytanie zwracające liczbę kobiet, pracujących w zawodzie o podanej przy EXECUTE nazwie.

```sql
SET @sql = 'SELECT COUNT(*)
            FROM Pracownicy P
            JOIN Ludzie L ON P.ludzie_id = L.id
            JOIN Zawody Z ON P.zawod_id = Z.zawod_id
            WHERE L.plec = "K" AND Z.nazwa = ?';

PREPARE stmt FROM @sql;

-- Przykładowe wywołanie
SET @zawod = 'nauczyciel';
EXECUTE stmt USING @zawod;

DEALLOCATE PREPARE stmt;
```

## 5

### Zrób backup bazy danych, usuń ją i przywróć. Jaka jest różnica między backupem pełnym a różnicowym?

```bash
# Backup
mysqldump -u root -p Lab3_Firma > backup.sql
# Usunięcie
mysql -u root -p -e "DROP DATABASE Lab3_Firma;"
# Przywrócenie
mysql -u root -p < backup.sql
```

**Odpowiedź:**

- **Backup pełny:** Kopia całej zawartości bazy danych. Jest czasochłonny i zajmuje dużo miejsca, ale łatwo z niego przywrócić system (wymaga tylko jednego pliku).
- **Backup różnicowy:** Zawiera tylko dane zmienione od ostatniego pełnego backupu. Jest szybszy i mniejszy, ale do przywrócenia wymaga ostatniego backupu pełnego oraz pliku różnicowego.

## 6

### WebGoat: SQL Injection (intro, advanced, mitigation).

#### SQL Injection (intro)

Polega na wstrzyknięciu kodu, który zmienia logikę zapytania (np. weryfikację hasła).

- **Payload:** `' OR '1'='1`
- **Wynik:** Zapytanie `SELECT * FROM Users WHERE Name = '' OR '1'='1'` zwraca prawdę dla każdego rekordu.

#### SQL Injection (advanced)

Wykorzystanie `UNION` do pobrania danych z innych tabel.

- **Payload:** `1' UNION SELECT user_system_data, password, 1, 1 FROM user_system_data --`
- **Opis:** Dokleja wyniki z tabeli z hasłami do wyników widocznych na ekranie. Znak `--` zakomentowuje resztę oryginalnego zapytania.

#### SQL Injection (mitigation)

Ochrona polega na niestosowaniu konkatenacji stringów (sklejania zapytań). Należy używać **Prepared Statements**.

- **Kod podatny:**

```py
user_input = "admin' OR '1'='1"
# SQL Injection możliwe, bo sklejamy stringi
query = f"SELECT * FROM users WHERE name = '{user_input}'"
cursor.execute(query)
```

- **Kod bezpieczny:**

```py
user_input = "admin"
# Użycie placeholdera (%s lub ?)
query = "SELECT * FROM users WHERE name = %s"
# Baza danych sama zadba o "ucieczkę" niebezpiecznych znaków
cursor.execute(query, (user_input,))
```

W wersji bezpiecznej baza traktuje dane wejściowe wyłącznie jako tekst parametru, a nie kod wykonywalny.
