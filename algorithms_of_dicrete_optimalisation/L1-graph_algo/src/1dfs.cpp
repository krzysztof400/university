#include <bits/stdc++.h>
using namespace std;

struct Graph { bool directed; int n,m; vector<vector<int>> adj;
    void read(){
        string f; if(!(cin>>f)) exit(1);
        directed = (f=="D"||f=="d");
        cin>>n>>m; adj.assign(n+1,{});
        for(int i=0;i<m;i++){
            int u,v; cin>>u>>v;
            if(u>=1&&u<=n && v>=1&&v<=n){
                adj[u].push_back(v); if(!directed) adj[v].push_back(u);
            }
        }
    }
};

struct Res { vector<int> order; vector<pair<int,int>> tree; };

Res dfs(const Graph& G, int start){
    Res r;
    vector<char> vis(G.n+1,0);
    auto start_from=[&](int s){
        if(vis[s]) return;
        vector<pair<int,int>> st;
        st.emplace_back(s,0);
        vis[s]=1;
        r.order.push_back(s);
        while(!st.empty()){
            int u = st.back().first;
            int &it = st.back().second;
            if(it < (int)G.adj[u].size()){
                int v = G.adj[u][it++];
                if(!vis[v]){ 
                    vis[v]=1; 
                    r.tree.emplace_back(u,v); 
                    r.order.push_back(v); 
                    st.emplace_back(v,0); 
                }
            } else st.pop_back();
        }
    };
    if(start>=1 && start<=G.n) start_from(start);
    for(int i=1;i<=G.n;i++) if(!vis[i]) start_from(i);
    return r;
}

// ---------- simplified ASCII tree printer - generated by GPT5 ----------
void print_tree_ascii(const Res& res) {
    if (res.order.empty()) { cout << "DFS TREE (ASCII):\n(no nodes)\n"; return; }
    int maxv = 0;
    for (int v: res.order) maxv = max(maxv, v);
    for (auto &e: res.tree) { maxv = max(maxv, e.first); maxv = max(maxv, e.second); }

    vector<vector<int>> children(maxv+1);
    vector<int> parent(maxv+1, 0);
    for (auto &p: res.tree) { children[p.first].push_back(p.second); parent[p.second] = p.first; }
    for (int i=1;i<=maxv;++i) if(!children[i].empty()) sort(children[i].begin(), children[i].end());

    vector<char> root_seen(maxv+1,0);
    vector<int> roots;
    for (int v: res.order) if (!parent[v] && !root_seen[v]) { roots.push_back(v); root_seen[v]=1; }
    for (int i=1;i<=maxv;++i) if (!parent[i] && !root_seen[i]) { roots.push_back(i); root_seen[i]=1; }

    function<void(int,string,bool)> dfs_print = [&](int u, string pref, bool last){
        if (pref.empty()) cout << u << '\n';
        else cout << pref << (last ? "└─ " : "├─ ") << u << '\n';
        auto &ch = children[u];
        for (size_t i=0;i<ch.size();++i) {
            bool is_last = (i+1 == ch.size());
            string next = pref + (pref.empty() ? (last ? "   " : "│  ") : (last ? "   " : "│  "));
            dfs_print(ch[i], next, is_last);
        }
    };

    cout << "DFS TREE (ASCII):\n";
    if (res.tree.empty()) { for (int v: res.order) cout << v << '\n'; return; }

    bool first = true;
    for (int r: roots) {
        if (!first) cout << '\n';
        first = false;
        if (children[r].empty()) cout << r << '\n';
        else dfs_print(r, "", true);
    }
}
// ---------- end printer ----------

int main(int argc,char**argv){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int start=-1, print_tree=0;
    for(int i=1;i<argc;i++){
        string s=argv[i];
        if(s.rfind("start=",0)==0) start=stoi(s.substr(6));
        else if(s.rfind("print_tree=",0)==0) print_tree=stoi(s.substr(11));
    }
    Graph G; G.read();
    Res res = dfs(G,start);
    cout<<"VISIT_ORDER:";
    for(int v: res.order) cout<<' '<<v;
    cout<<"\n";
    if(print_tree){
        // cout<<"TREE_EDGES:\n";
        // for(auto &e: res.tree) cout<<e.first<<' '<<e.second<<'\n';
        // cout<<"\n";
        print_tree_ascii(res);
    }
    return 0;
}
