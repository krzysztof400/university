#include <bits/stdc++.h>
using namespace std;

struct Graph {
    bool directed;
    int n, m;
    vector<vector<int>> adj;
    void read() {
        string f; if (!(cin >> f)) exit(1);
        directed = (f == "D" || f == "d");
        cin >> n >> m; adj.assign(n+1, {});
        for (int i = 0; i < m; ++i) {
            int u, v; cin >> u >> v;
            if (u>=1 && u<=n && v>=1 && v<=n) {
                adj[u].push_back(v);
                if (!directed) adj[v].push_back(u);
            }
        }
    }
};

struct Res { vector<int> order; vector<pair<int,int>> tree; };

Res bfs(const Graph& G, int start) {
    Res r;
    vector<char> vis(G.n+1, 0);
    queue<int> q;
    auto start_from = [&](int s){
        if (vis[s]) return;
        vis[s]=1; 
        q.push(s); 
        r.order.push_back(s);
        while(!q.empty()){
            int u = q.front(); q.pop();
            for(int v: G.adj[u]) if(!vis[v]){
                vis[v]=1; 
                r.tree.emplace_back(u,v); 
                q.push(v); 
                r.order.push_back(v);
            }
        }
    };
    if (start>=1 && start<=G.n) start_from(start);
    for (int i=1;i<=G.n;++i) if(!vis[i]) start_from(i);
    return r;
}

// ---------- simplified ASCII tree printer - generated by GPT5----------
void print_tree_ascii(const Res& res) {
    if (res.order.empty()) { cout << "BFS TREE (ASCII):\n(no nodes)\n"; return; }

    int maxv = 0;
    for (int v: res.order) maxv = max(maxv, v);
    for (auto &e: res.tree) { maxv = max(maxv, e.first); maxv = max(maxv, e.second); }

    vector<vector<int>> children(maxv+1);
    vector<int> parent(maxv+1, 0);
    for (auto &p: res.tree) { children[p.first].push_back(p.second); parent[p.second] = p.first; }
    for (int i=1;i<=maxv;++i) if(!children[i].empty()) sort(children[i].begin(), children[i].end());

    vector<char> root_seen(maxv+1,0);
    vector<int> roots;
    for (int v: res.order) if (!parent[v] && !root_seen[v]) { roots.push_back(v); root_seen[v]=1; }
    for (int i=1;i<=maxv;++i) if (!parent[i] && !root_seen[i]) { roots.push_back(i); root_seen[i]=1; }

    function<void(int,string,bool)> dfs = [&](int u, string pref, bool last){
        if (pref.empty()) cout << u << '\n';
        else cout << pref << (last ? "└─ " : "├─ ") << u << '\n';
        auto &ch = children[u];
        for (size_t i=0;i<ch.size();++i) {
            bool is_last = (i+1 == ch.size());
            string next = pref + (pref.empty() ? (last ? "   " : "│  ") : (last ? "   " : "│  "));
            dfs(ch[i], next, is_last);
        }
    };

    cout << "BFS TREE (ASCII):\n";
    if (res.tree.empty()) {
        for (int v: res.order) cout << v << '\n';
        return;
    }

    bool first = true;
    for (int r: roots) {
        if (!first) cout << '\n';
        first = false;
        if (children[r].empty()) cout << r << '\n';
        else dfs(r, "", true);
    }
}
// ---------- end printer ----------

int main(int argc,char**argv){
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    int start=-1, print_tree=0;
    for (int i=1;i<argc;i++){
        string s=argv[i];
        if (s.rfind("start=",0)==0) start=stoi(s.substr(6));
        else if (s.rfind("print_tree=",0)==0) print_tree=stoi(s.substr(11));
    }
    Graph G; G.read();
    Res res = bfs(G,start);
    cout<<"VISIT_ORDER:";
    for (int v: res.order) cout<<' '<<v;
    cout<<"\n";
    if (print_tree) {
        // cout<<"TREE_EDGES:\n";
        // for (auto &e: res.tree) cout<<e.first<<' '<<e.second<<'\n';
        // cout<<"\n";
        print_tree_ascii(res);
    }
    return 0;
}
